# ADR 007: Screen Architecture (v2)

## Status
Accepted (Supersedes [001](001-screen-controllers.md)) on 2019-07-03

## Context
Our [current screen architecture](001-screen-controllers.md) has a bunch of problems:

- We currently recreate application state from the UI state, which is dependent on some hidden behaviour
	- RxBinding has initial value observables that emit the current event immediately.
	- All widgets on the screen save and restore state properly.
- The entire event stream is replayed because the system is setup in a way that they begin emission of events like ScreenCreated before the entire event handling loop is setup.
- Controller handles both the business logic and the view logic.

All of these things combine together to make testing and maintaining the screens hard. In addition, screens which perform a lot of business logic in memory require a lot of working around the fact that the architecture depends on the state being saved either in persistence or by the platform mechanisms.

## Decision

### Goals
- Separate presentation and business logic so that they can tested independently of each other.
- Make UI state explicit and save/restore it manually instead of depending on hidden behaviour.
- Should be easy to migrate from the v1 architecture to the v2 for existing screens.

### Implementation
We need to split the controller into two discrete pieces, each with their own responsibility.

- `UiStateProducer`: This will be responsible for performing the function of the controller related to the business logic.
- `UiChangeProducer`: This will be responsible for performing the function of the controller related to the presentation logic.

In addition, we introduce a helper class, `ViewControllerBinding`, which will be used to tie the state producer and consumer together with the event stream.

#### Reference implementation
A reference implementation of the complete architecture can be found at this [commit](https://github.com/simpledotorg/simple-android/blob/9e8412259e034e555fa40c2b07810a98d736df95/app/src/main/java/org/simple/clinic/shortcodesearchresult/ShortCodeSearchResultScreen.kt).

#### Terminology
- `Event`: A generated event. This will typically be events generated by the user interface, but might also include events generated by the platform like sensors, camera, etc. These will generally be represent as Kotlin data classes that implement the `UiEvent` interface.
- `UiState`: This is a Kotlin data class that represents everything needed to render the content of a given screen.
- `Ui`: This is an interface which represents all the functionality that the actual screen needs to provide to the controller.
- `UiChange`: This is a Kotlin lambda that has the signature `(Ui) -> Unit`.

#### Screen Setup Process
- Define a `UiState` for whatever view/screen is being built.
- Create a `UiStateProducer` which is an `ObservableTransformer<Event, UiState>`. This class will be responsible for business logic by transforming a stream of events into a stream of UI states.
- Create a `UiChangeProducer` which is an `ObservableTransformer<UiState, UiChange>`. This is responsible for presentation logic by transforming a stream of UI states into a stream of lambdas which will executed on the `Ui`.
- Create a controller which is an `ObservableTransformer<UiEvent, UiChange>` which will compose `UiStateProducer` and `UiChangeProducer` internally.
- Use the `ViewControllerBinding` to tie the event stream to the view.

##### Sample
```kotlin
@Inject
lateinit var uiStateProducer: ShortCodeSearchResultStateProducer

@Inject
lateinit var uiChangeProducer: ShortCodeSearchResultUiChangeProducer

lateinit var binding: ViewControllerBinding<UiEvent, ShortCodeSearchResultState, ShortCodeSearchResultUi>

override fun onFinishInflate() {
  // Inject the screen

  binding = ViewControllerBinding.bindToView(this, uiStateProducer, uiChangeProducer)

  newPatientButton.setOnClickListener { binding.onEvent(SearchPatient) }
}
```

### Goals Review

#### Separation of concerns and testability
Since the business logic and presentation logic are separated into two discrete components, testing them is a lot simpler since they can be tested independently of each other. In addition, we can test the behaviour of the business logic using value testing (asserting the generated states) which is a lot more readable than verifying behaviours using mocks.

#### UI state saving/restoration
Since the state of a screen is represented as a data class, saving and restoring the state is quite easy, and just has two steps:
1. Make the `UiState` class implement the `Parcelable` interface.
2. The `ViewControllerBinding` exposes two functions, `latestState()` and `restoreSavedState()`, which can be used in conjunction with the platform lifecycle methods.

#### Migrating from the older architecture
One of the major concerns about moving from the v1 architecture to v2 is breaking existing features while moving code around. Since both the v1 and v2 architectures expose the same overall interface (`ObservableTransformer<Event, UiChange>`), we can replace the controller in tests for the older screens with a composition of the state producer and state consumer and verify that no behaviours were changed when migrating.

## Consequences
In legacy controllers, events were cached and replayed as soon as the screen was inflated without waiting for it to be attached to the view hierarchy. In the v2 architecture, any events which are forwarded to the binding before the view will be lost and ignored. This is the correct way to implement the events, but some of the older screen controllers which were dependent on that behaviour might take more effort to migrate to the current architecture.